1.不考虑复杂度：
  对于每个点，左找做大值，右找最大值，其收益等于max(0,min(左，右)-自高度)；
  其时间复杂度为O(n^2);
  
  实现代码：
  public int trap(int[] height) {
        int length = height.length;
        int water_counter=0;
        //iterator 
        for(int i=0;i<length;i++){
            //max height of left
            int max_left=0;
            for(int j=0;j<i;j++){
                if(height[j]>max_left){
                    max_left=height[j];
                }
            }
            
            //max height of right
            int max_right=0;
            for(int j=i;j<length;j++){
                if(height[j]>max_right){
                    max_right=height[j];
                }
            }
            
            //wather counter
            water_counter+=Math.max(0,Math.min(max_left,max_right)-height[i]);    
        }
        return water_counter;
    }
    
    结论：
      测试用例超时
      
2.极值变化思想：
  每一个点能存储的水量是其所处左右结点最高值的最低值(木桶)，即将其看为一个连续型函数，求解其连续的两个最高值之间的差值；
  两个最高值分别为变化的结束(左升或平，右降)与变化的开始(左正，右平或降)；
  1.若 O_i < O_i-1 : left_top ;
  中间需水量=两峰最小值*宽度-格子数；


class Solution {
    public int trap(int[] height) {
         if(height==null || height.length<2)
            return 0;
        
        int length = height.length;
        int left_top=0;
        // int right_top=0;
        int trend=0; // 0:prepared;1:down;2:up;
        int block_counter=0;
        int water_counter=0;
        
        //iterator 
        for(int i=1;i<length;i++){
            if(trend>0){
                block_counter+=height[i];
            }
            
            if(trend == 0 && height[i] < height[i-1]){
                left_top = i-1;
                trend = 1;
            }else if(trend == 1 && height[i] > height[i-1]){
                trend = 2;
            }else if(trend == 2 && (height[i] <= height[i-1] || i == length)){
                water_counter+= Math.min(height[left_top],height[i-1])*(i-1-left_top)-block_counter;
                trend = 0;
                return water_counter;
            }
        }
        return water_counter;
    }
}
